
///////////////////////////////////////////////////////////////////////////////
//
//   FlatBuffers schema for WAMP v2 messages
//   Copyright (c) Crossbar.io Technologies GmbH and contributors
//   Licensed under the Apache 2.0 license
//
///////////////////////////////////////////////////////////////////////////////

// Usage: To generate code, enter flatc --python -o generated wamp.fbs
//
// Use one of:
//
//  --cpp        -c    Generate C++ headers for tables/structs.
//  --go         -g    Generate Go files for tables/structs.
//  --java       -j    Generate Java classes for tables/structs.
//  --js         -s    Generate JavaScript code for tables/structs.
//  --ts         -T    Generate TypeScript code for tables/structs.
//  --csharp     -n    Generate C# classes for tables/structs.
//  --python     -p    Generate Python files for tables/structs.
//  --php              Generate PHP files for tables/structs.


// declare a custom attribute to define WAMP URIs on elements
attribute "uri";

// declare a custom attribute to define UUIDs on elements
attribute "uuid";

// the schema objects will live here
namespace wamp;


table KeyValue {
    key: string (required, key);
    value: string;
}

/// Void type (table based) for use with services.
table Void
{
    // nothing here!
}


// the schema objects will live here
namespace wamp.proto;


/// WAMP message type IDs.
enum MessageType: uint16
{
    NULL = 0,
    HELLO = 1,
    WELCOME = 2,
    ABORT = 3,
    CHALLENGE = 4,
    AUTHENTICATE = 5,
    GOODBYE = 6,
    ERROR = 8,
    PUBLISH = 16,
    PUBLISHED = 17,
    SUBSCRIBE = 32,
    SUBSCRIBED = 33,
    UNSUBSCRIBE = 34,
    UNSUBSCRIBED = 35,
    EVENT = 36,
    EVENTRECEIVED = 37,     // 377 as custom message type
    CALL = 48,
    CANCEL = 49,
    RESULT = 50,
    REGISTER = 64,
    REGISTERED = 65,
    UNREGISTER = 66,
    UNREGISTERED = 67,
    INVOCATION = 68,
    INTERRUPT = 69,
    YIELD = 70
}


/// Application payload type.
enum Payload: uint8
{
    /// Plain app payload.
    PLAIN = 1,

    /// Encrypted app payload (Curve25519 / Cryptobox).
    CRYPTOBOX = 2
}


/// Application payload serializer types.
enum Serializer: uint8
{
    /// Use same serializer for the app payload as on the transport.
    /// This will be one of JSON, MSGPACK, CBOR or UBJSON.
    TRANSPORT = 1,
    
    /// Use JSON serializer (for dynamically typed app payload).
    JSON = 2,

    /// Use MsgPack serializer (for dynamically typed app payload).
    MSGPACK = 3,

    /// Use CBOR serializer (for dynamically typed app payload).
    CBOR = 4,

    /// Use UBJSON serializer (for dynamically typed app payload).
    UBJSON = 5,

    /// Explicit use of Flatbuffers for statically typed payload.
    FLATBUFFERS = 6
}


/// HELLO message (message_type = ): [HELLO, Realm|uri, Details|dict]
table Hello
{
    /// The URI of the WAMP realm to join.
    realm: string (required);

    /// The WAMP session roles and features to announce.
    roles: [string];

    /// The authentication ID to announce.
    authid: string;

    /// The authentication role to announce.
    authrole: string;

    /// Application-specific "extra data" to be forwarded to the client.
    authextra: KeyValue;

    /// Whether the client wants this to be a session that can be later resumed.
    resumable: bool;

    /// The session the client would like to resume.
    resume_session: uint64;

    /// The secure authorisation token to resume the session.
    resume_token: string;
}


/// WELCOME message (message_type = ): [WELCOME, Session|id, Details|dict]
table Welcome
{
    /// The WAMP session ID the other peer is assigned.
    session: uint64;

    /// The WAMP roles to announce.
    roles: [string];

    /// The effective realm the session is joined on.
    realm: string;

    /// The authentication ID assigned.
    authid: string;

    /// The authentication method in use.
    authrole: string;

    /// The authentication method in use.
    authmethod: string;

    /// The authentication provided in use.
    authprovider: string;

    /// Application-specific "extra data" to be forwarded to the client.
    authextra: KeyValue;

    /// Whether the session is a resumed one.
    resumed: bool;

    /// Whether this session can be resumed later.
    resumable: bool;

    /// The secure authorisation token to resume the session.
    resume_token: string;
}


/// ABORT message (message_type = ): [ABORT, Details|dict, Reason|uri]
table Abort
{
    /// WAMP or application error URI for aborting reason.
    reason: string;

    /// Optional human-readable closing message, e.g. for logging purposes.
    message: string;
}


/// CHALLENGE message (message_type = ): [CHALLENGE, Method|string, Extra|dict]
table Challenge
{
    /// The challenge method.
    method: string;

    /// Chellenge method specific information.
    extra: KeyValue;
}


/// AUTHENTICATE message (message_type = ): [AUTHENTICATE, Signature|string, Extra|dict]
table Authenticate
{
    /// The signature for the authentication challenge.
    signature: string;

    /// Authentication method specific information.
    extra: KeyValue;
}


/// GOODBYE message (message_type = ): [GOODBYE, Details|dict, Reason|uri]
table Goodbye
{
    /// Optional WAMP or application error URI for closing reason.
    reason: string;

    /// Optional human-readable closing message, e.g. for logging purposes.
    message: string;

    /// From the server: Whether the session is able to be resumed (true) or destroyed (false). From the client: Whether it should be resumable (true) or destroyed (false).
    resumable: bool;
}


/// ERROR message (message_type = ): [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict, Error|uri, Payload|binary]
table Error
{
    ///
    request_type: MessageType;

    /// 
    request: uint64 (key);

    /// 
    error: string (required);

    /// Raw application payload: error arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];
}


/// PUBLISH message (message_type = ): [PUBLISH, Request|id, Options|dict, Topic|uri, Payload|binary]
table Publish
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// The WAMP or application URI of the PubSub topic the event should be published to.
    topic: string (required);

    /// Raw application payload: error arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];

    /// If true, acknowledge the publication with a success or error response.
    acknowledge: bool;

    /// If true, exclude the publisher from receiving the event, even if he is subscribed (and eligible).
    exclude_me: bool = true;

    /// List of WAMP session IDs to exclude from receiving this event.
    exclude: [uint64];

    /// List of WAMP authids to exclude from receiving this event.
    exclude_authid: [string];

    /// List of WAMP authroles to exclude from receiving this event.
    exclude_authrole: [string];

    /// List of WAMP session IDs eligible to receive this event.
    eligible: [uint64];

    /// List of WAMP authids eligible to receive this event.
    eligible_authid: [string];

    /// List of WAMP authroles eligible to receive this event.
    eligible_authrole: [string];

    /// If true, request the broker retain this event.
    retain: bool;
}


/// PUBLISHED message (message_type = ): [PUBLISHED, PUBLISH.Request|id, Publication|id]
table Published
{
    /// The request ID of the original PUBLISH request.
    request: uint64 (key);

    /// The publication ID for the published event.
    publication: uint64;
}


/// Subscription topic matching method.
enum Match: uint8
{
    /// Match URI exact.
    EXACT = 1,

    /// Match URI by prefix.
    PREFIX = 2,

    /// Match URI by wildcard.
    WILDCARD = 3,
}


/// SUBSCRIBE message (message_type = ): [SUBSCRIBE, Request|id, Options|dict, Topic|uri]
table Subscribe
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// The WAMP or application URI of the PubSub topic the event should be published to.
    topic: string (required);

    /// The topic matching method to be used for the subscription.
    match: Match = EXACT;

    /// Whether the client wants the retained message we may have along with the subscription.
    get_retained: bool;
}


/// SUBSCRIBED message (message_type = ): [SUBSCRIBED, SUBSCRIBE.Request|id, Subscription|id]
table Subscribed
{
    /// The request ID of the original SUBSCRIBE request.
    request: uint64 (key);

    /// The subscription ID for the subscribed topic (or topic pattern).
    subscription: uint64;
}


/// UNSUBSCRIBE message (message_type = ): [UNSUBSCRIBE, Request|id, SUBSCRIBED.Subscription|id]
table Unsubscribe
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// The subscription ID for the subscription to unsubscribe from.
    subscription: uint64;
}


/// UNSUBSCRIBED message (message_type = ): [UNSUBSCRIBED, UNSUBSCRIBE.Request|id, Details|dict]
table Unsubscribed
{
    /// The request ID of the original UNSUBSCRIBE request or 0 if the router triggered the unsubscribe ("router subscription revocation signaling").
    request: uint64 (key);

    /// If unsubscribe was actively triggered by router, the ID of the subscription revoked.
    subscription: uint64;

    /// The reason (an URI) for an active (router initiated) revocation.
    reason: string;
}


/// EVENT message (message_type = 36): [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict, PUBLISH.Payload|binary]
table Event
{
}


/// EVENT message (message_type = 37): [EVENT_RECEIVED, EVENT.Publication|id, Details|dict]
table EventReceived
{
    /// The publication ID of the event that was received, and that is acknowledged.
    publication: uint64;

    /// Raw application payload: error arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];
}


/// CALL message (message_type = 48): [CALL, Request|id, Options|dict, Procedure|uri, Payload|binary]
table Call
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// The WAMP or application URI of the procedure which should be called.
    procedure: string (required);

    /// Raw application payload: call arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];

    /// If present, cancel the call after this duration in ms.
    timeout: uint32;

    /// When set, indicates that the caller wants to receive progressive call results.
    receive_progress: bool;
}


/// Call cancel mode.
enum CancelMode: uint8
{
    SKIP = 1,
    ABORT = 2,
    KILL = 3
}


/// CANCEL message (message_type = ): [CANCEL, CALL.Request|id, Options|dict]
table Cancel
{
    /// The request ID of the original CALL request.
    request: uint64 (key);

    /// Specifies how to cancel the call.
    mode: CancelMode = SKIP;
}


/// RESULT message (message_type = 50): [RESULT, CALL.Request|id, Details|dict, Payload|binary]
table Result
{
    /// The request ID of the original CALL request.
    request: uint64 (key);

    /// Raw application payload: call result. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];

    /// If true, this result is a progressive call result, and subsequent results (or a final error) will follow.
    progress: bool;
}


/// REGISTER message (message_type = ): [REGISTER, Request|id, Options|dict, Procedure|uri]
table Register
{
    ///
    request: uint64 (key);

    ///
    procedure: string (required);

    ///
    match: Match = EXACT;

    ///
    //invoke: InvocationPolicy;

    ///
    concurrency: uint16;

    ///
    force_reregister: bool;
}


table Registered
{
}


table Unregister
{
}


table Unregistered
{
}


table Invocation
{
}


table Interrupt
{
}


table Yield
{
}


// a WAMP message is of exactly one of the following 24 concrete message types
union Messages
{
    Hello,
    Welcome,
    Abort,
    Challenge,
    Authenticate,
    Goodbye,
    Error,
    Publish,
    Published,
    Subscribe,
    Subscribed,
    Unsubscribe,
    Unsubscribed,
    Event,
    Call,
    Cancel,
    Result,
    Register,
    Registered,
    Unregister,
    Unregistered,
    Invocation,
    Interrupt,
    Yield
}


/// A WAMP message.
table Message
{
    // the following will add a type field ("msg") that discriminates the union
    // over all concrete WAMP message types
    msg: Messages;
}


/// The Flatbuffers root type is our WAMP message type.
root_type Message;
