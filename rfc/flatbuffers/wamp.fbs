
///////////////////////////////////////////////////////////////////////////////
//
//   FlatBuffers schema for WAMP v2 messages
//   Copyright (c) Crossbar.io Technologies GmbH and contributors
//   Licensed under the Apache 2.0 license
//
///////////////////////////////////////////////////////////////////////////////

// Usage: To generate code, enter flatc --python -o generated wamp.fbs
//
// Use one of:
//
//  --cpp        -c    Generate C++ headers for tables/structs.
//  --go         -g    Generate Go files for tables/structs.
//  --java       -j    Generate Java classes for tables/structs.
//  --js         -s    Generate JavaScript code for tables/structs.
//  --ts         -T    Generate TypeScript code for tables/structs.
//  --csharp     -n    Generate C# classes for tables/structs.
//  --python     -p    Generate Python files for tables/structs.
//  --php              Generate PHP files for tables/structs.


// declare a custom attribute to define WAMP URIs on elements
attribute "uri";

// declare a custom attribute to define UUIDs on elements
attribute "uuid";


// Namespace for WAMP.
namespace wamp;


// Simple mapping, from string keys to string values.
table Map {
    // Key, which must match the regular expression `[A-Za-z_][A-Za-z0-9_]*`. That
    // makes keys a valid identified in FlatBuffers (and most programming languages)
    key: string (required, key);

    // Value, which may be any (UTF8 encoded Unicode) string.
    value: string;
}

/// Void type (table based) for use with services.
table Void
{
    // nothing here!
}


// Namespace for WAMP protocol.
namespace wamp.proto;


/// WAMP message type IDs.
enum MessageType: uint16
{
    // No valid message type
    NULL = 0,

    // Session opening, authentication and closing
    HELLO = 1,
    WELCOME = 2,
    ABORT = 3,
    CHALLENGE = 4,
    AUTHENTICATE = 5,
    GOODBYE = 6,

    // Used in both PubSub and RPC
    ERROR = 8,

    // Publish & Subscribe (PubSub)
    PUBLISH = 16,
    PUBLISHED = 17,
    SUBSCRIBER_RECEIVED = 18,   // NEW: for "survey mode" PubSub (receiving app level
                                // feedback from event receivers)
    SUBSCRIBE = 32,
    SUBSCRIBED = 33,
    UNSUBSCRIBE = 34,
    UNSUBSCRIBED = 35,
    EVENT = 36,
    EVENT_RECEIVED = 37,        // NEW: for QoS level 2 PubSub ("exactly once delivery")
                                // as well as "survey mode" PubSub response carrying

    // Remote Procedure Calls (RPC)
    CALL = 48,
    CANCEL = 49,
    RESULT = 50,
    REGISTER = 64,
    REGISTERED = 65,
    UNREGISTER = 66,
    UNREGISTERED = 67,
    INVOCATION = 68,
    INTERRUPT = 69,
    YIELD = 70
}


/// Application payload type.
enum Payload: uint8
{
    /// Plain app payload.
    PLAIN = 1,

    /// Encrypted app payload using WAMP-cryptobox (Curve25519 / Cryptobox).
    CRYPTOBOX = 2,

    /// Raw MQTT app payload.
    MQTT = 3
}


/// Application payload serializer types.
enum Serializer: uint8
{
    /// Use same serializer for the app payload as on the transport.
    /// This will be one of JSON, MSGPACK, CBOR or UBJSON.
    TRANSPORT = 1,
    
    /// Use JSON serializer (for dynamically typed app payload).
    JSON = 2,

    /// Use MsgPack serializer (for dynamically typed app payload).
    MSGPACK = 3,

    /// Use CBOR serializer (for dynamically typed app payload).
    CBOR = 4,

    /// Use UBJSON serializer (for dynamically typed app payload).
    UBJSON = 5,

    /// Explicit use of Flatbuffers for statically typed payload.
    FLATBUFFERS = 6
}


/// HELLO message (message_type = ): [HELLO, Realm|uri, Details|dict]
table Hello
{
    /// The URI of the WAMP realm to join.
    realm: string (required);

    /// The WAMP session roles and features to announce.
    roles: [string];

    /// The authentication ID to announce.
    authid: string;

    /// The authentication role to announce.
    authrole: string;

    /// Application-specific "extra data" to be forwarded to the client.
    authextra: Map;

    /// Whether the client wants this to be a session that can be later resumed.
    resumable: bool;

    /// The session the client would like to resume.
    resume_session: uint64;

    /// The secure authorisation token to resume the session.
    resume_token: string;
}


/// WELCOME message (message_type = ): [WELCOME, Session|id, Details|dict]
table Welcome
{
    /// The WAMP session ID the other peer is assigned.
    session: uint64;

    /// The WAMP roles to announce.
    roles: [string];

    /// The effective realm the session is joined on.
    realm: string;

    /// The authentication ID assigned.
    authid: string;

    /// The authentication method in use.
    authrole: string;

    /// The authentication method in use.
    authmethod: string;

    /// The authentication provided in use.
    authprovider: string;

    /// Application-specific "extra data" to be forwarded to the client.
    authextra: Map;

    /// Whether the session is a resumed one.
    resumed: bool;

    /// Whether this session can be resumed later.
    resumable: bool;

    /// The secure authorisation token to resume the session.
    resume_token: string;
}


/// ABORT message (message_type = ): [ABORT, Details|dict, Reason|uri]
table Abort
{
    /// WAMP or application error URI for aborting reason.
    reason: string;

    /// Optional human-readable closing message, e.g. for logging purposes.
    message: string;
}


/// CHALLENGE message (message_type = ): [CHALLENGE, Method|string, Extra|dict]
table Challenge
{
    /// The challenge method.
    method: string;

    /// Chellenge method specific information.
    extra: Map;
}


/// AUTHENTICATE message (message_type = ): [AUTHENTICATE, Signature|string, Extra|dict]
table Authenticate
{
    /// The signature for the authentication challenge.
    signature: string;

    /// Authentication method specific information.
    extra: Map;
}


/// GOODBYE message (message_type = ): [GOODBYE, Details|dict, Reason|uri]
table Goodbye
{
    /// Optional WAMP or application error URI for closing reason.
    reason: string;

    /// Optional human-readable closing message, e.g. for logging purposes.
    message: string;

    /// From the server: Whether the session is able to be resumed (true) or destroyed (false). From the client: Whether it should be resumable (true) or destroyed (false).
    resumable: bool;
}


/// ERROR message (message_type = ): [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict, Error|uri, Payload|binary]
table Error
{
    ///
    request_type: MessageType;

    /// 
    request: uint64 (key);

    /// 
    error: string (required);

    /// Raw application payload: error arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];
}


/// Subscription topic matching method.
enum Match: uint8
{
    /// Match URI exact.
    EXACT = 1,

    /// Match URI by prefix.
    PREFIX = 2,

    /// Match URI by wildcard.
    WILDCARD = 3,
}


/// SUBSCRIBE message (message_type = ): [SUBSCRIBE, Request|id, Options|dict, Topic|uri]
table Subscribe
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// The WAMP or application URI of the PubSub topic the event should be published to.
    topic: string (required);

    /// The topic matching method to be used for the subscription.
    match: Match = EXACT;

    /// Whether the client wants the retained message we may have along with the subscription.
    get_retained: bool;
}


/// SUBSCRIBED message (message_type = ): [SUBSCRIBED, SUBSCRIBE.Request|id, Subscription|id]
table Subscribed
{
    /// The request ID of the original SUBSCRIBE request.
    request: uint64 (key);

    /// The subscription ID for the subscribed topic (or topic pattern).
    subscription: uint64;
}


/// UNSUBSCRIBE message (message_type = ): [UNSUBSCRIBE, Request|id, SUBSCRIBED.Subscription|id]
table Unsubscribe
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// The subscription ID for the subscription to unsubscribe from.
    subscription: uint64;
}


/// UNSUBSCRIBED message (message_type = ): [UNSUBSCRIBED, UNSUBSCRIBE.Request|id, Details|dict]
table Unsubscribed
{
    /// The request ID of the original UNSUBSCRIBE request or 0 if the router triggered the unsubscribe ("router subscription revocation signaling").
    request: uint64 (key);

    /// If unsubscribe was actively triggered by router, the ID of the subscription revoked.
    subscription: uint64;

    /// The reason (an URI) for an active (router initiated) revocation.
    reason: string;
}


/// PUBLISH message (message_type = ): [PUBLISH, Request|id, Options|dict, Topic|uri, Payload|binary]
table Publish
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// The WAMP or application URI of the PubSub topic the event should be published to.
    topic: string (required);

    /// Raw application payload: error arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];

    /// If true, acknowledge the publication with a success or error response.
    acknowledge: bool;

    /// If true, exclude the publisher from receiving the event, even if he is subscribed (and eligible).
    exclude_me: bool = true;

    /// List of WAMP session IDs to exclude from receiving this event.
    exclude: [uint64];

    /// List of WAMP authids to exclude from receiving this event.
    exclude_authid: [string];

    /// List of WAMP authroles to exclude from receiving this event.
    exclude_authrole: [string];

    /// List of WAMP session IDs eligible to receive this event.
    eligible: [uint64];

    /// List of WAMP authids eligible to receive this event.
    eligible_authid: [string];

    /// List of WAMP authroles eligible to receive this event.
    eligible_authrole: [string];

    /// If true, request the broker retain this event.
    retain: bool;
}


/// PUBLISHED message (message_type = ): [PUBLISHED, PUBLISH.Request|id, Publication|id]
table Published
{
    /// The request ID of the original PUBLISH request.
    request: uint64 (key);

    /// The publication ID for the published event.
    publication: uint64;
}


/// EVENT message (message_type = 36): [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict, PUBLISH.Payload|binary]
table Event
{
    /// The subscription ID this event is dispatched under.
    subscription: uint64;

    /// The publication ID of the dispatched event.
    publication: uint64;

    /// Raw application payload: error arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];

    /// The WAMP session ID of the pubisher. Only filled when the publisher is disclosed.
    publisher: uint64;

    /// The WAMP authrole of the publisher. Only filled when publisher is disclosed.
    publisher_authid: string;

    /// The WAMP authrole of the publisher. Only filled when publisher is disclosed.
    publisher_authrole: string;

    /// For pattern-based subscriptions, the event MUST contain the actual topic published to.
    topic: string;

    /// Whether the message was retained by the broker on the topic, rather than just published.
    retained: bool;

    /// Hint to request acknowledgement of the reception of this Event by a subscriber.
    acknowledge: bool;
}


/// EVENT_RECEIVED message (message_type = 37): [EVENT_RECEIVED, EVENT.Publication|id, Details|dict, Payload|binary]
table EventReceived
{
    /// The publication ID of the event that was received, and that is acknowledged.
    publication: uint64;

    /// Raw application payload: error arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];
}


/// SUBSCRIBER_RECEIVED message (message_type = 38): [SUBSCRIBER_RECEIVED, EVENT_RECEIVED.Publication|id, Details|dict, EVENT_RECEIVED.Payload|binary]
table PublicationReceived
{
    /// The publication ID of the event that was received, and that is acknowledged.
    publication: uint64;

    /// Raw application payload: error arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];
}


/// CALL message (message_type = 48): [CALL, Request|id, Options|dict, Procedure|uri, Payload|binary]
table Call
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// The WAMP or application URI of the procedure which should be called.
    procedure: string (required);

    /// Raw application payload: call arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];

    /// If present, cancel the call after this duration in ms.
    timeout: uint32;

    /// When set, indicates that the caller wants to receive progressive call results.
    receive_progress: bool;
}


/// Call cancel mode.
enum CancelMode: uint8
{
    SKIP = 1,
    ABORT = 2,
    KILL = 3
}


/// CANCEL message (message_type = ): [CANCEL, CALL.Request|id, Options|dict]
table Cancel
{
    /// The request ID of the original CALL request.
    request: uint64 (key);

    /// Specifies how to cancel the call.
    mode: CancelMode = SKIP;
}


/// RESULT message (message_type = 50): [RESULT, CALL.Request|id, Details|dict, Payload|binary]
table Result
{
    /// The request ID of the original CALL request.
    request: uint64 (key);

    /// Raw application payload: call result. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];

    /// If true, this result is a progressive call result, and subsequent results (or a final error) will follow.
    progress: bool;
}


/// Remote procedure invocation policy, for use with shared registrations.
enum InvocationPolicy: uint8
{
    // Standard invocation policy: a procedure may only be registered by at most
    // one callee at a time. This is the default.
    SINGLE = 0,

    // First callee invocation policy: all calls to a procedure are forwarded to
    // the callee that first registered. Should that callee unregister, calls
    // are forwarded to the callee that registered next after the former.
    FIRST = 1,

    // Last callee invocation policy: all calls to a procedure are forwwrded to
    // the callee that last registered. Should that callee unregister, calls
    // are forwarded to the callee that registered next before the former.
    LAST = 2,

    // Round-robin invocation policy: calls are forward to all registered callees
    // in a round-robin fashion. Callees that unregister are removed from the
    // round-robin list, and new callees registering will get calls immediately
    // in the next dispatching round.
    ROUNDROBIN = 3,

    // Random invocation policy: calls are forwarded to all registered callees
    // in a random fashion. Callees that unregister are removed from the set
    // of callees randomly drawn from to dispatch incoming calls.
    RANDOM = 4
}


/// REGISTER message (message_type = ): [REGISTER, Request|id, Options|dict, Procedure|uri]
table Register
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// The WAMP or application URI of the RPC endpoint provided.
    procedure: string (required);

    /// The procedure matching policy to be used for the registration.
    match: Match = EXACT;

    /// The procedure invocation policy to be used for the registration.
    invoke: InvocationPolicy;

    /// The (maximum) concurrency to be used for the registration.
    concurrency: uint16;

    /// Force registration of procedure (kicking any existing registration).
    force_reregister: bool;
}


/// REGISTERED message (message_type = ): [REGISTERED, REGISTER.Request|id, Registration|id]
table Registered
{
    /// The request ID of the original ``REGISTER`` request.
    request: uint64 (key);

    /// The registration ID for the registered procedure (or procedure pattern).
    registration: uint64;
}


/// UNREGISTER message (message_type = ): [UNREGISTER, Request|id, REGISTERED.Registration|id]
table Unregister
{
    /// The request ID of the original ``REGISTER`` request.
    request: uint64 (key);

    /// The registration ID for the registration to unregister.
    registration: uint64;
}


/// UNREGISTERED message (message_type = 67): [UNREGISTERED, UNREGISTER.Request|id, Details|dict]
table Unregistered
{
    /// The request ID of the original UNREGISTER request.
    request: uint64 (key);

    /// If unregister was actively triggered by router, the ID of the registration revoked.
    registration: uint64;

    /// The reason (an URI) for revocation.
    reason: string;
}


/// INVOCATION message (message_type = 68): [INVOCATION, Request|id, REGISTERED.Registration|id, Details|dict, Payload|binary]
table Invocation
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// The registration ID of the endpoint to be invoked.
    registration: uint64;

    /// Raw application payload: call arguments. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];

    /// For pattern-based registrations (not for exact matching registrations, the invocation MUST include the actual procedure being called.
    procedure: string;

    /// If present, let the callee automatically cancels the invocation after this ms.
    timeout: uint32;

    /// Indicates if the callee should produce progressive results.
    receive_progress: bool;

    /// The WAMP session ID of the caller. Only filled if caller is disclosed.
    caller: uint64;

    /// The WAMP authid of the caller. Only filled if caller is disclosed.
    caller_authid: string;

    /// The WAMP authrole of the caller. Only filled if caller is disclosed.
    caller_authrole: string;
}


/// INTERRUPT message (message_type = ): [INTERRUPT, INVOCATION.Request|id, Options|dict]
table Interrupt
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// Specifies how to interrupt the invocation.
    mode: CancelMode = ABORT;
}


/// YIELD message (message_type = ): [YIELD, INVOCATION.Request|id, Options|dict, Payload|binary]
table Yield
{
    /// The WAMP request ID of this request.
    request: uint64 (key);

    /// Raw application payload: call result. This might be encrypted (with Payload==Payload.CRYPTOBOX), and is serialized according to enc_serializer.
    payload: [uint8];

    /// The encoding algorithm that was used to encode the payload.
    enc_algo: Payload = PLAIN;

    /// The payload object serializer that was used encoding the payload.
    enc_serializer: Serializer = TRANSPORT;

    /// When using Payload.CRYPTOBOX, the public Cryptobox key of the key pair used for encrypting the payload.
    enc_key: [uint8];
}


// a WAMP message is of exactly one of the following 24 concrete message types
union Messages
{
    Hello,
    Welcome,
    Abort,
    Challenge,
    Authenticate,
    Goodbye,
    Error,
    Publish,
    Published,
    Subscribe,
    Subscribed,
    Unsubscribe,
    Unsubscribed,
    Event,
    Call,
    Cancel,
    Result,
    Register,
    Registered,
    Unregister,
    Unregistered,
    Invocation,
    Interrupt,
    Yield
}


/// A WAMP message.
table Message
{
    // the following will add a type field ("msg") that discriminates the union
    // over all concrete WAMP message types
    msg: Messages;
}


/// The Flatbuffers root type is our WAMP message type.
root_type Message;
